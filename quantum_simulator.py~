#!/usr/bin/env python

import numpy as np # for numerics
import random # for random number generation
from math import sqrt,pi,e # some common function
import qutip as qp # qutip library for Bloch sphere visualisations
import cmath # library for complex numbers



#################### State functions
def create_state(num_qubits, lis):
    if len(lis) < 2**num_qubits:
            # check if all entries are valid positions
            if any(isinstance(item, complex) or item > 2**num_qubits \
                   or not isinstance(item, int) for item in lis) :
                raise StandardError('Cannot interpret input of State() creator.'\
                                    ' Please enter a list of valid positions.')
            # initialise state
            state = np.array([1./sqrt(len(lis)) if i in lis else 0 \
                                   for i in range(2**num_qubits)])
        # else if the list has as many entries as amplitudes (2**n),
        # interpret the entries as amplitudes
        elif len(lis) == 2**num_qubits:
            state = np.array(lis)

            if not is_normalised(state):
                state = renormalise(state)
                print 'Note thate the state you generated was normalised ' \
                    'automatically '

        else:
            raise StandardError('Cannot interpret input of State() creator.'\
                                ' Please enter a list of valid amplitudes or positions.')
    return state

#################### Gate functions



#################### Execution

state = create_state(2,[1])
